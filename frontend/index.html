<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IQadam</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Sora:wght@600;700;800&display=swap" rel="stylesheet">
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit" async defer></script>
    <link rel="stylesheet" href="/assets/styles.css">
</head>
<body>
    <section class="hero fade-transition min-h-[100svh] px-4 pt-14 md:px-8 md:pt-16" id="welcome-section">
        <div class="kyrgyz-sun"></div>
        <div class="relative z-10 mx-auto flex min-h-[78vh] max-w-6xl items-center">
            <div class="max-w-2xl rounded-3xl border border-blue-100 bg-white/70 p-7 shadow-[0_32px_90px_-48px_rgba(37,99,235,0.55)] backdrop-blur-sm md:p-10">
                <p class="brand-mark">IQadam</p>
                <h1 class="font-display mt-4 text-3xl font-extrabold leading-tight tracking-tight text-slate-900 md:text-5xl">
                    Prepare for ORT with full-length mock exams
                </h1>
                <p class="mt-5 text-base leading-relaxed text-slate-700 md:text-lg">
                    Practice with realistic questions, smooth exam flow, and focused sessions built for confident test-day performance.
                </p>
                <div class="mt-8 flex flex-wrap items-center gap-3">
                    <a href="#auth-section" class="font-display inline-flex items-center justify-center rounded-xl bg-blue-600 px-7 py-3 text-sm font-bold text-white transition hover:bg-blue-700">
                        Get Started
                    </a>
                </div>
            </div>
        </div>

        <div class="eagle" aria-hidden="true">
            <svg viewBox="0 0 140 46" role="presentation" focusable="false">
                <path d="M5 30c9-8 18-12 28-12 9 0 16 4 22 9 6-5 13-9 22-9 11 0 21 4 32 13-11-4-20-4-29-1-8 3-15 8-22 13-7-5-14-10-22-13-9-3-18-3-31 0z"/>
            </svg>
        </div>

        <div class="mountain-bridge" id="mountain-bridge" aria-hidden="true">
            <div class="mountain-layer mountain-back"></div>
            <div class="mountain-layer mountain-mid"></div>
            <div class="mountain-layer mountain-front"></div>
            <div class="bridge-snow"></div>
        </div>
    </section>

    <section id="auth-section" class="auth-lake fade-transition relative min-h-[58svh] overflow-hidden px-4 pb-6 pt-6 md:min-h-[54svh] md:px-8 md:pb-8 md:pt-8">
        <div id="auth-screen" class="relative z-10 mx-auto mt-10 max-w-md rounded-2xl border border-blue-100 bg-white/96 p-6 shadow-lg backdrop-blur-sm md:mt-12 md:p-8">
            <h2 id="auth-title" class="font-display mt-1 text-2xl font-extrabold tracking-tight text-slate-900">Sign In</h2>

            <div class="mt-6 mb-6 grid grid-cols-2 rounded-xl bg-blue-50 p-1">
                <button id="tab-login" class="rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-semibold text-white transition">Login</button>
                <button id="tab-register" class="rounded-lg px-4 py-2.5 text-sm font-medium text-blue-700 transition">Register</button>
            </div>

            <form id="login-form" class="space-y-4" autocomplete="off">
                <div>
                    <label for="login-email" class="mb-1.5 block text-sm font-medium text-slate-700">Email</label>
                    <input id="login-email" type="email" autocomplete="email" required class="w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm text-slate-900 outline-none transition focus:border-blue-500 focus:ring-4 focus:ring-blue-100" placeholder="you@example.com">
                </div>
                <div>
                    <label for="login-password" class="mb-1.5 block text-sm font-medium text-slate-700">Password</label>
                    <input id="login-password" type="password" autocomplete="new-password" required class="w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm text-slate-900 outline-none transition focus:border-blue-500 focus:ring-4 focus:ring-blue-100" placeholder="••••••••">
                </div>
                <div id="login-captcha" class="pt-1"></div>
                <button type="submit" class="font-display w-full rounded-xl bg-blue-600 px-4 py-3 text-sm font-bold text-white transition hover:bg-blue-700">Log In</button>
            </form>

            <form id="register-form" class="hidden space-y-4" autocomplete="off">
                <div>
                    <label for="register-email" class="mb-1.5 block text-sm font-medium text-slate-700">Email</label>
                    <input id="register-email" type="email" required class="w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm text-slate-900 outline-none transition focus:border-blue-500 focus:ring-4 focus:ring-blue-100" placeholder="you@example.com">
                </div>
                <div>
                    <label for="register-password" class="mb-1.5 block text-sm font-medium text-slate-700">Password</label>
                    <input id="register-password" type="password" autocomplete="new-password" minlength="8" required class="w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm text-slate-900 outline-none transition focus:border-blue-500 focus:ring-4 focus:ring-blue-100" placeholder="Strong password">
                    <p class="mt-2 text-xs text-slate-500">Use 8+ chars with upper, lower, number, and special character.</p>
                </div>
                <div>
                    <label for="register-confirm-password" class="mb-1.5 block text-sm font-medium text-slate-700">Confirm Password</label>
                    <input id="register-confirm-password" type="password" autocomplete="new-password" minlength="8" required class="w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm text-slate-900 outline-none transition focus:border-blue-500 focus:ring-4 focus:ring-blue-100" placeholder="Repeat your password">
                </div>
                <div id="register-captcha" class="pt-1"></div>
                <button type="submit" class="font-display w-full rounded-xl bg-blue-600 px-4 py-3 text-sm font-bold text-white transition hover:bg-blue-700">Create Account</button>
            </form>

            <p id="auth-message" class="mt-5 hidden rounded-xl px-4 py-3 text-sm"></p>
            <div id="resend-confirmation-wrap" class="mt-3 hidden">
                <button id="resend-confirmation-btn" class="w-full rounded-xl border border-slate-300 bg-white px-4 py-2.5 text-sm font-semibold text-slate-700 transition hover:border-blue-400 hover:bg-blue-50 hover:text-blue-700">
                    Resend confirmation email
                </button>
            </div>
        </div>
    </section>

    <section id="quiz-screen" class="fade-transition hidden mx-auto max-w-6xl px-4 pb-16 md:px-8">
        <div class="mb-5 flex flex-wrap items-center justify-between gap-3 rounded-2xl border border-blue-100 bg-white px-4 py-3 shadow-sm">
            <div class="flex items-center gap-3">
                <div class="kalpak-avatar" aria-hidden="true">
                    <span class="kalpak-hat"></span>
                    <span class="kalpak-head"></span>
                </div>
                <p id="user-email" class="text-sm font-semibold text-slate-800">-</p>
            </div>
            <button id="logout-btn" class="rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white transition hover:bg-slate-700">Log Out</button>
        </div>

        <div id="exam-selector" class="mb-5 rounded-2xl border border-blue-100 bg-white p-6 shadow-sm">
            <div class="mb-5">
                <h3 class="font-display text-2xl font-extrabold text-slate-900">Choose Your Mock Exam</h3>
            </div>
            <div id="exam-grid" class="space-y-2.5"></div>
            <div id="exam-mode-panel" class="exam-mode-panel mt-4 hidden rounded-2xl border p-3 md:p-4">
                <div class="grid gap-2 sm:grid-cols-2">
                    <button id="mode-no-timer-btn" type="button" class="mode-btn">
                        <span class="mode-btn-icon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.1" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 6l12 12"></path>
                                <circle cx="12" cy="13" r="7"></circle>
                            </svg>
                        </span>
                        <span class="mode-btn-label">No Timer</span>
                    </button>
                    <button id="mode-timer-btn" type="button" class="mode-btn">
                        <span class="mode-btn-icon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.1" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="13" r="7"></circle>
                                <path d="M12 13V9"></path>
                                <path d="M12 13l3 2"></path>
                                <path d="M9 3h6"></path>
                            </svg>
                        </span>
                        <span class="mode-btn-label">Timer</span>
                    </button>
                </div>
            </div>
            <p id="exam-message" class="mt-4 hidden rounded-xl border px-4 py-3 text-sm"></p>
        </div>

        <div class="fade-transition hidden rounded-2xl border border-blue-100 bg-white p-6 shadow-sm md:p-8" id="quiz-container">
            <div id="loading" class="fade-transition py-12 text-center">
                <h2 class="font-display animate-pulse text-2xl font-bold text-slate-600">Loading questions...</h2>
            </div>

            <div id="quiz-content" class="fade-transition hidden">
                <div class="mb-4 flex justify-end">
                    <span id="timer-badge" class="hidden rounded-full border border-blue-200 bg-blue-50 px-3 py-1 text-xs font-semibold tracking-[0.08em] text-blue-700">60:00</span>
                </div>
                <h2 id="question-text" class="font-display mb-6 text-xl font-bold leading-relaxed text-slate-900 md:text-2xl">Question Book</h2>

                <div id="options-container" class="book-page-shell mb-8"></div>

                <div class="flex justify-end">
                    <button id="next-btn" disabled class="font-display rounded-xl bg-blue-600 px-8 py-3 text-sm font-bold text-white transition hover:bg-blue-700 disabled:cursor-not-allowed disabled:opacity-50">Next Page</button>
                </div>
            </div>

            <div id="results-screen" class="fade-transition hidden py-12 text-center">
                <h2 class="font-display mb-4 text-3xl font-extrabold text-slate-900">Test completed</h2>
                <p id="results-summary" class="mb-8 text-lg text-slate-600">You answered all questions.</p>
                <button id="restart-btn" class="font-display rounded-xl bg-blue-600 px-8 py-3 text-sm font-bold text-white transition hover:bg-blue-700">Review Mistakes</button>
            </div>
        </div>
    </section>

    <script>
        const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://127.0.0.1:8000'
            : 'https://iqadam-production.up.railway.app'; // Added https://
        const ACCESS_TOKEN_KEY = 'ort_access_token';
        const USER_EMAIL_KEY = 'ort_user_email';
        const SELECTED_EXAM_KEY = 'ort_selected_exam';
        const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        const MOCK_EXAMS = [16, 17, 18, 19, 20, 21, 22];
        const AVAILABLE_EXAMS = new Set([19]);
        const DEFAULT_AVAILABLE_EXAM = 19;
        const EXAM_TIMER_SECONDS = 60 * 60;

        let questions = [];
        let currentPageIndex = 0;
        let questionsPerPage = 2;
        let answers = [];
        const answersByQuestionId = new Map();
        let reviewMode = false;
        let reviewQuestions = [];
        let selectedExamMode = null;
        let timerIntervalId = null;
        let resizeRerenderTimerId = null;
        let timerRemainingSeconds = EXAM_TIMER_SECONDS;
        let timerActive = false;
        let completingExam = false;
        let authToken = localStorage.getItem(ACCESS_TOKEN_KEY);
        let selectedMockExam = Number(localStorage.getItem(SELECTED_EXAM_KEY)) || null;
        let pendingConfirmationEmail = '';
        const questionCache = new Map();
        const questionFetches = new Map();
        let captchaEnabled = false;
        let captchaSiteKey = null;
        let loginCaptchaToken = '';
        let registerCaptchaToken = '';
        let loginCaptchaWidgetId = null;
        let registerCaptchaWidgetId = null;

        const welcomeSection = document.getElementById('welcome-section');
        const authSection = document.getElementById('auth-section');
        const authScreen = document.getElementById('auth-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const examSelector = document.getElementById('exam-selector');
        const examGrid = document.getElementById('exam-grid');
        const examModePanel = document.getElementById('exam-mode-panel');
        const modeNoTimerBtn = document.getElementById('mode-no-timer-btn');
        const modeTimerBtn = document.getElementById('mode-timer-btn');
        const examMessage = document.getElementById('exam-message');
        const authMessage = document.getElementById('auth-message');
        const authTitle = document.getElementById('auth-title');
        const resendWrap = document.getElementById('resend-confirmation-wrap');
        const resendBtn = document.getElementById('resend-confirmation-btn');
        const tabLogin = document.getElementById('tab-login');
        const tabRegister = document.getElementById('tab-register');
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const loginCaptchaMount = document.getElementById('login-captcha');
        const registerCaptchaMount = document.getElementById('register-captcha');
        const loginSubmitBtn = loginForm.querySelector('button[type="submit"]');
        const registerSubmitBtn = registerForm.querySelector('button[type="submit"]');
        const userEmail = document.getElementById('user-email');
        const logoutBtn = document.getElementById('logout-btn');

        const quizContainer = document.getElementById('quiz-container');
        const loadingDiv = document.getElementById('loading');
        const quizContentDiv = document.getElementById('quiz-content');
        const resultsScreenDiv = document.getElementById('results-screen');
        const resultsSummary = document.getElementById('results-summary');
        const questionText = document.getElementById('question-text');
        const timerBadge = document.getElementById('timer-badge');
        const optionsContainer = document.getElementById('options-container');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const questionOrderMap = new Map();
        const ROOT_SCREEN_IDS = ['welcome-section', 'auth-section', 'quiz-screen'];
        const FADE_DURATION_MS = 300;
        const fadeState = new WeakMap();
        let activeScreenId = ROOT_SCREEN_IDS.find((id) => {
            const el = document.getElementById(id);
            return el && !el.classList.contains('hidden');
        }) || 'welcome-section';

        function wait(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function markFadeState(element) {
            const next = (fadeState.get(element) || 0) + 1;
            fadeState.set(element, next);
            return next;
        }

        function initializeFadeElement(element) {
            if (!element) return;
            element.classList.add('fade-transition');
            element.style.opacity = element.classList.contains('hidden') ? '0' : '1';
        }

        function showElementInstant(element) {
            if (!element) return;
            markFadeState(element);
            element.classList.remove('hidden');
            element.style.opacity = '1';
        }

        function hideElementInstant(element) {
            if (!element) return;
            markFadeState(element);
            element.classList.add('hidden');
            element.style.opacity = '0';
        }

        async function fadeInElement(element) {
            if (!element) return;
            if (!element.classList.contains('hidden') && element.style.opacity !== '0') {
                element.style.opacity = '1';
                return;
            }
            const token = markFadeState(element);
            element.classList.remove('hidden');
            element.style.opacity = '0';
            void element.offsetWidth;
            element.style.opacity = '1';
            await wait(FADE_DURATION_MS);
            if (fadeState.get(element) !== token) return;
            element.style.opacity = '1';
        }

        async function fadeOutElement(element) {
            if (!element || element.classList.contains('hidden')) return;
            const token = markFadeState(element);
            element.style.opacity = '0';
            await wait(FADE_DURATION_MS);
            if (fadeState.get(element) !== token) return;
            element.classList.add('hidden');
        }

        async function showScreen(screenId) {
            const target = document.getElementById(screenId);
            if (!target) return;
            if (activeScreenId === screenId && !target.classList.contains('hidden') && target.style.opacity !== '0') {
                return;
            }

            const fallbackCurrentId = ROOT_SCREEN_IDS.find((id) => {
                if (id === screenId) return false;
                const el = document.getElementById(id);
                return el && !el.classList.contains('hidden');
            });
            const currentId = activeScreenId !== screenId ? activeScreenId : fallbackCurrentId;
            const current = currentId ? document.getElementById(currentId) : null;

            if (current && current !== target) {
                await fadeOutElement(current);
            }
            await fadeInElement(target);
            activeScreenId = screenId;
        }

        async function showQuizSubview(targetElement) {
            const subviews = [loadingDiv, quizContentDiv, resultsScreenDiv];
            await Promise.all(subviews.map((element) => (
                element === targetElement ? fadeInElement(element) : fadeOutElement(element)
            )));
        }

        function initializeTransitions() {
            [
                welcomeSection,
                authSection,
                quizScreen,
                examModePanel,
                quizContainer,
                loadingDiv,
                quizContentDiv,
                resultsScreenDiv,
                timerBadge
            ].forEach(initializeFadeElement);
        }

        function normalizeEmail(value) {
            return value.trim().toLowerCase();
        }

        function isValidEmail(email) {
            return EMAIL_REGEX.test(email) && email.length <= 254;
        }

        function getPasswordValidationError(password) {
            if (password.length < 8) return 'Password must be at least 8 characters.';
            if (!/[a-z]/.test(password)) return 'Password must include a lowercase letter.';
            if (!/[A-Z]/.test(password)) return 'Password must include an uppercase letter.';
            if (!/\d/.test(password)) return 'Password must include a number.';
            if (!/[^A-Za-z0-9]/.test(password)) return 'Password must include a special character.';
            if (/\s/.test(password)) return 'Password cannot contain spaces.';
            if (password.length > 128) return 'Password is too long.';
            return null;
        }

        function setButtonLoading(button, isLoading, loadingText) {
            if (!button) return;
            if (isLoading) {
                if (!button.dataset.defaultLabel) button.dataset.defaultLabel = button.textContent.trim();
                button.textContent = loadingText;
                button.disabled = true;
                button.classList.add('cursor-not-allowed', 'opacity-70');
                return;
            }
            button.textContent = button.dataset.defaultLabel || button.textContent;
            button.disabled = false;
            button.classList.remove('cursor-not-allowed', 'opacity-70');
        }

        function extractApiErrorMessage(data) {
            if (!data) return 'Request failed.';
            if (typeof data.detail === 'string') return data.detail;
            if (Array.isArray(data.detail)) {
                const messages = data.detail.map((item) => item?.msg).filter(Boolean);
                if (messages.length > 0) return messages.join(' ');
            }
            if (typeof data.message === 'string') return data.message;
            return 'Request failed.';
        }

        function hideResendConfirmation() {
            pendingConfirmationEmail = '';
            hideElementInstant(resendWrap);
        }

        function showResendConfirmation(email) {
            pendingConfirmationEmail = normalizeEmail(email || '');
            showElementInstant(resendWrap);
        }

        function resetCaptcha(widgetType) {
            if (!captchaEnabled || !window.turnstile) return;
            if (widgetType === 'login' && loginCaptchaWidgetId !== null) {
                window.turnstile.reset(loginCaptchaWidgetId);
                loginCaptchaToken = '';
            }
            if (widgetType === 'register' && registerCaptchaWidgetId !== null) {
                window.turnstile.reset(registerCaptchaWidgetId);
                registerCaptchaToken = '';
            }
        }

        function showExamMessage(text, type = 'info') {
            showElementInstant(examMessage);
            examMessage.classList.remove('border-rose-200', 'bg-rose-50', 'text-rose-700', 'border-blue-200', 'bg-blue-50', 'text-blue-700', 'border-emerald-200', 'bg-emerald-50', 'text-emerald-700');
            if (type === 'error') {
                examMessage.classList.add('border-rose-200', 'bg-rose-50', 'text-rose-700');
            } else if (type === 'success') {
                examMessage.classList.add('border-emerald-200', 'bg-emerald-50', 'text-emerald-700');
            } else {
                examMessage.classList.add('border-blue-200', 'bg-blue-50', 'text-blue-700');
            }
            examMessage.textContent = text;
        }

        function hideExamMessage() {
            hideElementInstant(examMessage);
            examMessage.textContent = '';
        }

        function formatTimer(seconds) {
            const safeSeconds = Math.max(0, Number(seconds) || 0);
            const minutes = Math.floor(safeSeconds / 60);
            const secs = safeSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateTimerBadge() {
            timerBadge.textContent = formatTimer(timerRemainingSeconds);
            timerBadge.classList.remove('border-rose-200', 'bg-rose-50', 'text-rose-700', 'border-blue-200', 'bg-blue-50', 'text-blue-700');
            if (timerRemainingSeconds <= 120) {
                timerBadge.classList.add('border-rose-200', 'bg-rose-50', 'text-rose-700');
            } else {
                timerBadge.classList.add('border-blue-200', 'bg-blue-50', 'text-blue-700');
            }
        }

        function stopExamTimer() {
            if (timerIntervalId !== null) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            timerActive = false;
            timerRemainingSeconds = EXAM_TIMER_SECONDS;
            updateTimerBadge();
            hideElementInstant(timerBadge);
        }

        async function handleTimerExpired() {
            if (reviewMode) return;
            showExamMessage('Time is up. Exam finished automatically.', 'info');
            await finishExam({ skipConfirmation: true });
        }

        function startExamTimer() {
            stopExamTimer();
            timerActive = true;
            timerRemainingSeconds = EXAM_TIMER_SECONDS;
            updateTimerBadge();
            showElementInstant(timerBadge);
            timerIntervalId = window.setInterval(() => {
                if (!timerActive) return;
                timerRemainingSeconds -= 1;
                if (timerRemainingSeconds <= 0) {
                    timerRemainingSeconds = 0;
                    updateTimerBadge();
                    stopExamTimer();
                    void handleTimerExpired();
                    return;
                }
                updateTimerBadge();
            }, 1000);
        }

        function setModeButtonsState() {
            modeNoTimerBtn.className = selectedExamMode === 'untimed'
                ? 'mode-btn mode-btn-active'
                : 'mode-btn';

            modeTimerBtn.className = selectedExamMode === 'timed'
                ? 'mode-btn mode-btn-active'
                : 'mode-btn';
        }

        function hideExamModePanel() {
            hideElementInstant(examModePanel);
        }

        function showExamModePanel(examNo) {
            if (!AVAILABLE_EXAMS.has(examNo)) {
                hideExamModePanel();
                return;
            }
            showElementInstant(examModePanel);
            setModeButtonsState();
        }

        function getDefaultAvailableExam() {
            if (AVAILABLE_EXAMS.has(DEFAULT_AVAILABLE_EXAM)) return DEFAULT_AVAILABLE_EXAM;
            return MOCK_EXAMS.find((examNo) => AVAILABLE_EXAMS.has(examNo)) || null;
        }

        function getQuestionsPerPage() {
            if (window.innerWidth >= 1280) return 4;
            if (window.innerWidth >= 768) return 3;
            return 2;
        }

        function getRenderableQuestions() {
            return reviewMode ? reviewQuestions : questions;
        }

        function getTotalPages() {
            const renderableQuestions = getRenderableQuestions();
            if (!renderableQuestions.length) return 0;
            return Math.ceil(renderableQuestions.length / questionsPerPage);
        }

        function getPageSlice(pageIndex = currentPageIndex) {
            const renderableQuestions = getRenderableQuestions();
            const startIndex = pageIndex * questionsPerPage;
            const items = renderableQuestions.slice(startIndex, startIndex + questionsPerPage);
            return { startIndex, items };
        }

        function getCorrectOptionKey(question) {
            const candidateKeys = ['correct_answer', 'correct_option', 'answer_key', 'answer'];
            for (const key of candidateKeys) {
                const value = question?.[key];
                if (typeof value !== 'string') continue;
                const normalized = value.trim().toUpperCase();
                if (!normalized) continue;
                return normalized[0];
            }
            return null;
        }

        function getScoreSummary() {
            const total = questions.length;
            let correct = 0;
            for (const question of questions) {
                const correctOption = getCorrectOptionKey(question);
                const selectedOption = answersByQuestionId.get(String(question.id)) || null;
                if (correctOption && selectedOption === correctOption) {
                    correct += 1;
                }
            }
            const scorePercent = total > 0 ? Math.round((correct / total) * 100) : 0;
            return { correct, total, scorePercent };
        }

        function getReviewQuestions() {
            const mistakes = questions.filter((question) => {
                const selectedOption = answersByQuestionId.get(String(question.id)) || null;
                const correctOption = getCorrectOptionKey(question);
                if (!selectedOption) return true;
                if (!correctOption) return true;
                return selectedOption !== correctOption;
            });
            return mistakes.length > 0 ? mistakes : [...questions];
        }

        function setOptionVisualState(button, isSelected) {
            if (!button) return;
            button.className = isSelected
                ? 'quiz-option w-full rounded-xl border border-blue-500 bg-blue-50/80 px-4 py-3 text-left shadow-sm transition'
                : 'quiz-option w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-left transition hover:border-blue-300 hover:bg-blue-50/70';
            button.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
            const letter = button.querySelector('.option-letter');
            if (!letter) return;
            letter.className = isSelected
                ? 'option-letter bg-blue-500 text-white'
                : 'option-letter bg-slate-200 text-slate-700';
        }

        function setReviewOptionVisualState(button, selectedOption, correctOption) {
            if (!button) return;
            const optionKey = button.dataset.optionKey;
            button.className = 'quiz-option w-full rounded-xl border border-slate-200 bg-slate-50/70 px-4 py-3 text-left transition cursor-default';
            button.setAttribute('aria-pressed', 'false');
            button.disabled = true;

            const letter = button.querySelector('.option-letter');
            if (!letter) return;

            if (correctOption && optionKey === correctOption) {
                button.className = 'quiz-option w-full rounded-xl border border-emerald-300 bg-emerald-50/90 px-4 py-3 text-left transition cursor-default';
                letter.className = 'option-letter bg-emerald-500 text-white';
                return;
            }

            if (selectedOption && optionKey === selectedOption && selectedOption !== correctOption) {
                button.className = 'quiz-option w-full rounded-xl border border-rose-300 bg-rose-50/90 px-4 py-3 text-left transition cursor-default';
                letter.className = 'option-letter bg-rose-500 text-white';
                return;
            }

            letter.className = 'option-letter bg-slate-200 text-slate-700';
        }

        function refreshNextButtonState() {
            const totalPages = getTotalPages();
            if (!totalPages) {
                nextBtn.disabled = true;
                nextBtn.textContent = 'Next Page';
                return;
            }
            if (reviewMode) {
                nextBtn.textContent = currentPageIndex < totalPages - 1 ? 'Next Page' : 'Back to Results';
                nextBtn.disabled = false;
                return;
            }
            nextBtn.textContent = currentPageIndex < totalPages - 1 ? 'Next Page' : 'Finish Exam';
            nextBtn.disabled = false;
        }

        function applyQuestionsToQuiz(data) {
            questions = Array.isArray(data) ? data : [];
            questionOrderMap.clear();
            for (let i = 0; i < questions.length; i += 1) {
                questionOrderMap.set(String(questions[i].id), i + 1);
            }
            currentPageIndex = 0;
            questionsPerPage = getQuestionsPerPage();
            answers = [];
            answersByQuestionId.clear();
            reviewMode = false;
            reviewQuestions = [];
        }

        function renderMockExamCards() {
            examGrid.innerHTML = '';
            const cardsFragment = document.createDocumentFragment();
            for (const examNo of MOCK_EXAMS) {
                const isAvailable = AVAILABLE_EXAMS.has(examNo);
                const isSelected = selectedMockExam === examNo;
                const card = document.createElement('button');
                card.type = 'button';
                card.className = isSelected
                    ? 'w-full rounded-xl border border-blue-500 bg-blue-50 px-4 py-3 text-left shadow-sm transition'
                    : 'w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-left transition hover:border-blue-300 hover:bg-blue-50/60';

                const statusBadge = isAvailable
                    ? '<span class="rounded-full bg-emerald-100 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-[0.12em] text-emerald-700">Ready</span>'
                    : '<span class="rounded-full bg-slate-200 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-[0.12em] text-slate-600">Locked</span>';

                card.innerHTML = `
                    <div class="flex items-center justify-between gap-3">
                        <p class="font-display text-base font-bold text-slate-900">Mock Exam ${examNo}</p>
                        ${statusBadge}
                    </div>
                `;

                card.addEventListener('click', () => {
                    void selectMockExam(examNo);
                });
                if (!isAvailable) {
                    card.classList.add('cursor-not-allowed', 'opacity-65');
                }

                cardsFragment.appendChild(card);
            }
            examGrid.appendChild(cardsFragment);
        }

        async function selectMockExam(examNo) {
            selectedMockExam = examNo;
            selectedExamMode = null;
            localStorage.setItem(SELECTED_EXAM_KEY, String(examNo));
            renderMockExamCards();
            setModeButtonsState();

            if (!AVAILABLE_EXAMS.has(examNo)) {
                hideExamModePanel();
                showExamMessage(`Mock Exam ${examNo} is coming soon.`, 'info');
                return;
            }

            showExamModePanel(examNo);
            hideExamMessage();
            void fetchQuestions(examNo, { startQuizOnLoad: false, showLoader: false }).catch(() => {});
        }

        async function startSelectedExam(mode) {
            if (!selectedMockExam) {
                showExamMessage('Select a mock exam first.', 'error');
                return;
            }
            if (!AVAILABLE_EXAMS.has(selectedMockExam)) {
                showExamMessage(`Mock Exam ${selectedMockExam} is coming soon.`, 'info');
                return;
            }

            selectedExamMode = mode;
            setModeButtonsState();
            hideExamModePanel();
            stopExamTimer();
            showExamMessage(
                `Starting Mock Exam ${selectedMockExam} ${mode === 'timed' ? 'with timer' : 'without timer'}...`,
                'info'
            );

            try {
                await fetchQuestions(selectedMockExam, {
                    startQuizOnLoad: true,
                    showLoader: !questionCache.has(selectedMockExam)
                });
            } catch {
                // Error UI is handled inside fetchQuestions.
            }
        }

        async function loadAuthConfig() {
            try {
                const config = await apiRequest('/api/auth/config');
                captchaEnabled = Boolean(config.captcha_enabled && config.captcha_site_key);
                captchaSiteKey = config.captcha_site_key || null;
            } catch {
                captchaEnabled = false;
                captchaSiteKey = null;
            }
        }

        async function waitForTurnstile(maxAttempts = 40, delayMs = 150) {
            for (let i = 0; i < maxAttempts; i += 1) {
                if (window.turnstile) return true;
                await new Promise((resolve) => setTimeout(resolve, delayMs));
            }
            return false;
        }

        async function renderCaptchaWidgets() {
            if (!captchaEnabled) {
                loginCaptchaMount.innerHTML = '';
                registerCaptchaMount.innerHTML = '';
                return;
            }

            const ready = await waitForTurnstile();
            if (!ready) {
                showAuthMessage('Captcha failed to load. Refresh the page and try again.');
                return;
            }

            loginCaptchaWidgetId = window.turnstile.render('#login-captcha', {
                sitekey: captchaSiteKey,
                theme: 'light',
                callback: (token) => { loginCaptchaToken = token; },
                'expired-callback': () => { loginCaptchaToken = ''; },
                'error-callback': () => { loginCaptchaToken = ''; }
            });

            registerCaptchaWidgetId = window.turnstile.render('#register-captcha', {
                sitekey: captchaSiteKey,
                theme: 'light',
                callback: (token) => { registerCaptchaToken = token; },
                'expired-callback': () => { registerCaptchaToken = ''; },
                'error-callback': () => { registerCaptchaToken = ''; }
            });
        }

        function showAuthMessage(text, type = 'error') {
            showElementInstant(authMessage);
            authMessage.classList.remove('bg-red-100', 'text-red-700', 'border-red-200', 'bg-green-100', 'text-green-700', 'border-green-200', 'bg-blue-100', 'text-blue-700', 'border-blue-200');
            if (type === 'success') {
                authMessage.classList.add('bg-green-100', 'text-green-700', 'border', 'border-green-200');
            } else if (type === 'info') {
                authMessage.classList.add('bg-blue-100', 'text-blue-700', 'border', 'border-blue-200');
            } else {
                authMessage.classList.add('bg-red-100', 'text-red-700', 'border', 'border-red-200');
            }
            authMessage.textContent = text;
        }

        function resetAuthMessage() {
            hideElementInstant(authMessage);
            authMessage.textContent = '';
        }

        function activateTab(tab) {
            const isLogin = tab === 'login';
            authTitle.textContent = isLogin ? 'Sign In' : 'Create Account';

            tabLogin.className = isLogin
                ? 'rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-semibold text-white transition'
                : 'rounded-lg px-4 py-2.5 text-sm font-medium text-blue-700 transition';

            tabRegister.className = !isLogin
                ? 'rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-semibold text-white transition'
                : 'rounded-lg px-4 py-2.5 text-sm font-medium text-blue-700 transition';

            if (isLogin) {
                showElementInstant(loginForm);
                hideElementInstant(registerForm);
            } else {
                showElementInstant(registerForm);
                hideElementInstant(loginForm);
            }
            hideResendConfirmation();
            resetAuthMessage();
            if (captchaEnabled) {
                resetCaptcha('login');
                resetCaptcha('register');
            }
        }

        async function apiRequest(path, options = {}) {
            const config = { ...options };
            config.headers = { ...(options.headers || {}) };
            if (!config.headers['Content-Type'] && options.body) {
                config.headers['Content-Type'] = 'application/json';
            }

            const response = await fetch(`${API_BASE}${path}`, config);
            let data = {};
            try {
                data = await response.json();
            } catch {
                data = {};
            }

            if (!response.ok) {
                throw new Error(extractApiErrorMessage(data));
            }

            return data;
        }

        function saveSession(session, email) {
            authToken = session.access_token;
            localStorage.setItem(ACCESS_TOKEN_KEY, session.access_token);
            localStorage.setItem(USER_EMAIL_KEY, email || '');
        }

        function clearSession() {
            authToken = null;
            localStorage.removeItem(ACCESS_TOKEN_KEY);
            localStorage.removeItem(USER_EMAIL_KEY);
        }

        function resetAuthForms() {
            loginForm.reset();
            registerForm.reset();
            pendingConfirmationEmail = '';
            hideResendConfirmation();
            resetAuthMessage();
            const loginPassword = document.getElementById('login-password');
            const registerPassword = document.getElementById('register-password');
            const registerConfirmPassword = document.getElementById('register-confirm-password');
            if (loginPassword) loginPassword.value = '';
            if (registerPassword) registerPassword.value = '';
            if (registerConfirmPassword) registerConfirmPassword.value = '';
        }

        function resetQuizState() {
            questions = [];
            questionOrderMap.clear();
            currentPageIndex = 0;
            questionsPerPage = getQuestionsPerPage();
            answers = [];
            answersByQuestionId.clear();
            reviewMode = false;
            reviewQuestions = [];
            selectedExamMode = null;
            stopExamTimer();
            hideElementInstant(quizContainer);
            showElementInstant(loadingDiv);
            loadingDiv.innerHTML = '<h2 class="font-display animate-pulse text-2xl font-bold text-slate-600">Loading questions...</h2>';
            hideElementInstant(quizContentDiv);
            hideElementInstant(resultsScreenDiv);
            hideExamModePanel();
            hideExamMessage();
            nextBtn.textContent = 'Next Page';
            nextBtn.disabled = true;
            restartBtn.textContent = 'Review Mistakes';
        }

        async function showAuthScreen(scrollToAuth = false) {
            resetQuizState();
            await Promise.all([
                showScreen('welcome-section'),
                fadeInElement(authSection)
            ]);
            if (scrollToAuth) {
                authScreen.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        async function showQuizScreen(email) {
            userEmail.textContent = email || localStorage.getItem(USER_EMAIL_KEY) || '-';
            hideResendConfirmation();
            resetAuthMessage();
            await Promise.all([
                showScreen('quiz-screen'),
                fadeOutElement(authSection)
            ]);
            showElementInstant(examSelector);
            const selectedAvailableExam = AVAILABLE_EXAMS.has(selectedMockExam) ? selectedMockExam : null;
            const preloadExam = selectedAvailableExam || getDefaultAvailableExam();
            if (!selectedAvailableExam) {
                selectedMockExam = null;
                localStorage.removeItem(SELECTED_EXAM_KEY);
            }
            renderMockExamCards();
            resetQuizState();
            if (selectedAvailableExam) {
                showExamModePanel(selectedAvailableExam);
                hideExamMessage();
            } else {
                hideExamModePanel();
                hideExamMessage();
            }
            if (preloadExam) {
                void fetchQuestions(preloadExam, { startQuizOnLoad: false, showLoader: false }).catch(() => {});
            }
            quizScreen.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        async function verifyExistingSession() {
            if (!authToken) return false;
            try {
                const data = await apiRequest('/api/auth/me', {
                    headers: { Authorization: `Bearer ${authToken}` }
                });
                await showQuizScreen(data.user?.email);
                return true;
            } catch {
                clearSession();
                return false;
            }
        }

        async function fetchQuestions(examNo = selectedMockExam, options = {}) {
            const { startQuizOnLoad = false, showLoader = true } = options;
            if (!examNo) {
                showExamMessage('Select a mock exam to load questions.', 'error');
                return;
            }
            if (!AVAILABLE_EXAMS.has(examNo)) {
                resetQuizState();
                showExamMessage(`Mock Exam ${examNo} is coming soon.`, 'info');
                return;
            }

            if (questionCache.has(examNo)) {
                const cachedQuestions = questionCache.get(examNo);
                if (startQuizOnLoad) {
                    applyQuestionsToQuiz(cachedQuestions);
                    await fadeInElement(quizContainer);
                    await startQuiz();
                    showExamMessage(`Mock Exam ${examNo} loaded.`, 'success');
                }
                return cachedQuestions;
            }

            let requestPromise = questionFetches.get(examNo);
            if (!requestPromise) {
                requestPromise = (async () => {
                    const response = await fetch(`${API_BASE}/api/questions?mock_exam=${examNo}`, {
                        headers: authToken ? { Authorization: `Bearer ${authToken}` } : {}
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(extractApiErrorMessage(data));
                    }
                    if (!Array.isArray(data) || data.length === 0) {
                        throw new Error(`No questions found for Mock Exam ${examNo}.`);
                    }

                    questionCache.set(examNo, data);
                    return data;
                })();

                questionFetches.set(examNo, requestPromise);
                requestPromise.finally(() => {
                    if (questionFetches.get(examNo) === requestPromise) {
                        questionFetches.delete(examNo);
                    }
                });
            }

            if (startQuizOnLoad && showLoader) {
                await fadeInElement(quizContainer);
                await showQuizSubview(loadingDiv);
                hideExamMessage();
            }

            try {
                const data = await requestPromise;
                if (startQuizOnLoad) {
                    applyQuestionsToQuiz(data);
                    await startQuiz();
                    showExamMessage(`Mock Exam ${examNo} loaded.`, 'success');
                }
                return data;
            } catch (error) {
                if (startQuizOnLoad) {
                    loadingDiv.innerHTML = `<p class="text-rose-500">${error.message || 'Server connection error.'}</p>`;
                }
                throw error;
            }
        }

        async function startQuiz() {
            await showQuizSubview(quizContentDiv);
            if (!reviewMode && selectedExamMode === 'timed') {
                startExamTimer();
            } else {
                stopExamTimer();
            }
            renderQuestionPage();
        }

        function renderQuestionPage() {
            questionsPerPage = getQuestionsPerPage();
            const totalPages = getTotalPages();
            if (!totalPages) {
                questionText.innerText = 'No questions available.';
                optionsContainer.innerHTML = '';
                refreshNextButtonState();
                return;
            }

            if (currentPageIndex >= totalPages) {
                currentPageIndex = totalPages - 1;
            }

            const { startIndex, items } = getPageSlice(currentPageIndex);
            questionText.innerText = 'Практическая грамматика русского языка';
            optionsContainer.innerHTML = '';
            const questionCardsFragment = document.createDocumentFragment();

            items.forEach((question, offset) => {
                const questionId = String(question.id);
                const questionNo = questionOrderMap.get(questionId) || (startIndex + offset + 1);
                const questionCard = document.createElement('article');
                questionCard.className = 'book-question-card rounded-2xl border border-slate-200 bg-white/95 p-5 shadow-[0_8px_28px_-24px_rgba(15,23,42,0.45)]';
                questionCard.dataset.questionId = questionId;

                const optionButtons = Object.entries(question.options || {})
                    .filter(([, value]) => Boolean(value))
                    .map(([key, value]) => `
                        <button type="button" class="quiz-option w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-left transition hover:border-blue-300 hover:bg-blue-50/70" data-option-key="${key}" aria-pressed="false">
                            <span class="option-letter bg-slate-200 text-slate-700">${key}</span>
                            <span class="option-text text-slate-800">${value}</span>
                        </button>
                    `)
                    .join('');

                questionCard.innerHTML = `
                    <div class="mb-4">
                        <span class="rounded-full bg-slate-100 px-3 py-1 text-xs font-semibold uppercase tracking-[0.12em] text-slate-600">Question ${questionNo}</span>
                    </div>
                    <h3 class="font-display mb-4 text-lg font-bold leading-relaxed text-slate-900">${question.question_text}</h3>
                    <div class="space-y-2.5">
                        ${optionButtons}
                    </div>
                `;

                const selectedOption = answersByQuestionId.get(questionId);
                const correctOption = getCorrectOptionKey(question);
                questionCard.querySelectorAll('[data-option-key]').forEach((button) => {
                    const optionKey = button.dataset.optionKey;
                    if (reviewMode) {
                        setReviewOptionVisualState(button, selectedOption, correctOption);
                    } else {
                        setOptionVisualState(button, optionKey === selectedOption);
                        button.addEventListener('click', () => selectOption(questionId, optionKey, button));
                    }
                });

                if (reviewMode) {
                    const reviewInfo = document.createElement('p');
                    reviewInfo.className = 'mt-3 text-sm';
                    if (!selectedOption && correctOption) {
                        reviewInfo.classList.add('text-amber-700');
                        reviewInfo.textContent = `Skipped. Correct answer: ${correctOption}.`;
                    } else if (selectedOption && correctOption && selectedOption !== correctOption) {
                        reviewInfo.classList.add('text-rose-700');
                        reviewInfo.textContent = `Your answer: ${selectedOption}. Correct answer: ${correctOption}.`;
                    } else if (!correctOption) {
                        reviewInfo.classList.add('text-slate-600');
                        reviewInfo.textContent = selectedOption
                            ? `Your answer: ${selectedOption}. Correct answer is unavailable.`
                            : 'Skipped. Correct answer is unavailable.';
                    } else {
                        reviewInfo.classList.add('text-emerald-700');
                        reviewInfo.textContent = `Correct answer: ${correctOption}.`;
                    }
                    questionCard.appendChild(reviewInfo);
                }

                questionCardsFragment.appendChild(questionCard);
            });

            optionsContainer.appendChild(questionCardsFragment);
            refreshNextButtonState();
        }

        function selectOption(questionId, optionKey, element) {
            if (reviewMode) return;
            answersByQuestionId.set(questionId, optionKey);
            const questionCard = element.closest('[data-question-id]');
            if (!questionCard) return;
            questionCard.querySelectorAll('[data-option-key]').forEach((optionButton) => {
                setOptionVisualState(optionButton, optionButton.dataset.optionKey === optionKey);
            });
            refreshNextButtonState();
        }

        async function showResults() {
            reviewMode = false;
            reviewQuestions = [];
            stopExamTimer();
            const { correct, total, scorePercent } = getScoreSummary();
            resultsSummary.textContent = `You have answered correctly ${correct}/${total} questions. Your score is: ${scorePercent}%.`;
            restartBtn.textContent = 'Review Mistakes';
            await showQuizSubview(resultsScreenDiv);
        }

        function getSkippedCount() {
            const answeredCount = questions.reduce((total, question) => (
                answersByQuestionId.has(String(question.id)) ? total + 1 : total
            ), 0);
            return Math.max(0, questions.length - answeredCount);
        }

        async function finishExam({ skipConfirmation = false } = {}) {
            if (completingExam) return;
            if (!skipConfirmation) {
                const skippedCount = getSkippedCount();
                if (skippedCount > 0) {
                    const confirmed = window.confirm(
                        `You skipped ${skippedCount} question${skippedCount === 1 ? '' : 's'}. Are you sure you want to finish the exam?`
                    );
                    if (!confirmed) return;
                }
            }

            completingExam = true;
            try {
                answers = questions.map((question) => ({
                    question_id: question.id,
                    selected: answersByQuestionId.get(String(question.id)) || null
                }));
                await showResults();
            } finally {
                completingExam = false;
            }
        }

        loginForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            resetAuthMessage();
            hideResendConfirmation();

            const email = normalizeEmail(document.getElementById('login-email').value);
            const password = document.getElementById('login-password').value;

            if (!isValidEmail(email)) return showAuthMessage('Enter a valid email address.');
            if (!password || !password.trim()) return showAuthMessage('Password is required.');
            if (captchaEnabled && !loginCaptchaToken) return showAuthMessage('Complete captcha verification before logging in.');

            setButtonLoading(loginSubmitBtn, true, 'Logging In...');
            try {
                const data = await apiRequest('/api/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ email, password, captcha_token: loginCaptchaToken || null })
                });

                saveSession(data.session, data.user?.email || email);
                await showQuizScreen(data.user?.email || email);
            } catch (error) {
                showAuthMessage(error.message || 'Login failed.');
                if ((error.message || '').toLowerCase().includes('not confirmed')) {
                    showResendConfirmation(email);
                }
            } finally {
                setButtonLoading(loginSubmitBtn, false);
                resetCaptcha('login');
            }
        });

        registerForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            resetAuthMessage();
            hideResendConfirmation();

            const email = normalizeEmail(document.getElementById('register-email').value);
            const password = document.getElementById('register-password').value;
            const confirmPassword = document.getElementById('register-confirm-password').value;

            if (!isValidEmail(email)) return showAuthMessage('Enter a valid email address.');
            const passwordError = getPasswordValidationError(password);
            if (passwordError) return showAuthMessage(passwordError);
            if (password !== confirmPassword) return showAuthMessage('Passwords do not match.');
            if (captchaEnabled && !registerCaptchaToken) return showAuthMessage('Complete captcha verification before registering.');

            setButtonLoading(registerSubmitBtn, true, 'Creating Account...');
            try {
                const data = await apiRequest('/api/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ email, password, captcha_token: registerCaptchaToken || null })
                });

                if (data.session && data.session.access_token) {
                    saveSession(data.session, data.user?.email || email);
                    showAuthMessage('Account created and logged in.', 'success');
                    await showQuizScreen(data.user?.email || email);
                    return;
                }

                activateTab('login');
                document.getElementById('login-email').value = email;
                showAuthMessage('Account created. Confirm your email, then log in.', 'info');
                showResendConfirmation(email);
            } catch (error) {
                showAuthMessage(error.message || 'Registration failed.');
            } finally {
                setButtonLoading(registerSubmitBtn, false);
                resetCaptcha('register');
            }
        });

        resendBtn.addEventListener('click', async () => {
            resetAuthMessage();
            const loginEmail = normalizeEmail(document.getElementById('login-email').value);
            const registerEmail = normalizeEmail(document.getElementById('register-email').value);
            const email = pendingConfirmationEmail || loginEmail || registerEmail;

            if (!isValidEmail(email)) return showAuthMessage('Enter a valid email before resending confirmation.');

            setButtonLoading(resendBtn, true, 'Sending...');
            try {
                const data = await apiRequest('/api/auth/resend-confirmation', {
                    method: 'POST',
                    body: JSON.stringify({ email })
                });
                showAuthMessage(data.message || 'Confirmation email sent.', 'info');
            } catch (error) {
                showAuthMessage(error.message || 'Could not resend confirmation.');
            } finally {
                setButtonLoading(resendBtn, false);
            }
        });

        nextBtn.addEventListener('click', async () => {
            if (nextBtn.disabled) return;
            const totalPages = getTotalPages();
            if (!totalPages) return;

            if (reviewMode) {
                if (currentPageIndex < totalPages - 1) {
                    currentPageIndex += 1;
                    renderQuestionPage();
                    quizContentDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    return;
                }
                await showResults();
                return;
            }

            if (currentPageIndex < totalPages - 1) {
                currentPageIndex += 1;
                renderQuestionPage();
                quizContentDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                return;
            }
            await finishExam();
        });

        restartBtn.addEventListener('click', async () => {
            if (!questions.length) return;
            reviewMode = true;
            reviewQuestions = getReviewQuestions();
            currentPageIndex = 0;
            await showQuizSubview(quizContentDiv);
            renderQuestionPage();
            quizContentDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });

        modeNoTimerBtn.addEventListener('click', async () => {
            await startSelectedExam('untimed');
        });

        modeTimerBtn.addEventListener('click', async () => {
            await startSelectedExam('timed');
        });

        logoutBtn.addEventListener('click', async () => {
            clearSession();
            selectedMockExam = null;
            localStorage.removeItem(SELECTED_EXAM_KEY);
            resetAuthForms();
            activateTab('login');
            await showAuthScreen(true);
            resetCaptcha('login');
            resetCaptcha('register');
        });

        tabLogin.addEventListener('click', () => activateTab('login'));
        tabRegister.addEventListener('click', () => activateTab('register'));

        window.addEventListener('resize', () => {
            if (!questions.length || quizContentDiv.classList.contains('hidden')) return;
            if (resizeRerenderTimerId !== null) {
                clearTimeout(resizeRerenderTimerId);
            }
            resizeRerenderTimerId = window.setTimeout(() => {
                resizeRerenderTimerId = null;
                const nextPerPage = getQuestionsPerPage();
                if (nextPerPage === questionsPerPage) return;
                const firstVisibleQuestion = currentPageIndex * questionsPerPage;
                questionsPerPage = nextPerPage;
                currentPageIndex = Math.floor(firstVisibleQuestion / questionsPerPage);
                renderQuestionPage();
            }, 120);
        });

        window.addEventListener('DOMContentLoaded', async () => {
            initializeTransitions();
            setModeButtonsState();
            await loadAuthConfig();
            await renderCaptchaWidgets();
            activateTab('login');
            const sessionValid = await verifyExistingSession();
            if (!sessionValid) await showAuthScreen(false);
        });
    </script>
</body>
</html>
